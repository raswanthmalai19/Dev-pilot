"""
Infrastructure Agent - Generates Terraform configurations for cloud deployment.
Supports auto-apply mode for fully automated infrastructure provisioning.
"""

from pathlib import Path
from typing import Dict, Any, List, Callable, Optional
from datetime import datetime

from .base_agent import BaseAgent
from ..models.project import ProjectInfo
from ..models.deployment import DeploymentConfig, ContainerConfig, CloudProvider
from ..core.terraform_client import (
    TerraformClient,
    TerraformPlan,
    TerraformApplyResult,
)
from ..core.health_checker import HealthChecker, verify_deployment


# Terraform templates
MAIN_TF_TEMPLATE = '''# Terraform configuration for {{ service_name }}
# Generated by DevOps Automation Agent

terraform {
  required_version = ">= 1.0"
  
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
  
  # Uncomment to use remote backend
  # backend "gcs" {
  #   bucket = "your-terraform-state-bucket"
  #   prefix = "{{ service_name }}"
  # }
}

provider "google" {
  project = var.project_id
  region  = var.region
}

# Enable required APIs
resource "google_project_service" "run_api" {
  service            = "run.googleapis.com"
  disable_on_destroy = false
}

resource "google_project_service" "artifact_registry_api" {
  service            = "artifactregistry.googleapis.com"
  disable_on_destroy = false
}

# Artifact Registry repository
resource "google_artifact_registry_repository" "app_repo" {
  location      = var.region
  repository_id = "{{ service_name }}"
  description   = "Docker repository for {{ service_name }}"
  format        = "DOCKER"
  
  depends_on = [google_project_service.artifact_registry_api]
}

# Cloud Run service
resource "google_cloud_run_v2_service" "app" {
  name     = var.service_name
  location = var.region
  
  template {
    containers {
      image = var.container_image
      
      ports {
        container_port = var.container_port
      }
      
      resources {
        limits = {
          cpu    = var.cpu
          memory = var.memory
        }
      }
      
      # Environment variables
      {% for key, value in env_vars.items() %}
      env {
        name  = "{{ key }}"
        value = "{{ value }}"
      }
      {% endfor %}
      
      # Startup probe
      startup_probe {
        http_get {
          path = var.health_check_path
          port = var.container_port
        }
        initial_delay_seconds = 5
        timeout_seconds       = 3
        period_seconds        = 5
        failure_threshold     = 3
      }
      
      # Liveness probe
      liveness_probe {
        http_get {
          path = var.health_check_path
          port = var.container_port
        }
        initial_delay_seconds = 10
        timeout_seconds       = 3
        period_seconds        = 30
      }
    }
    
    scaling {
      min_instance_count = var.min_instances
      max_instance_count = var.max_instances
    }
    
    service_account = google_service_account.app_sa.email
  }
  
  traffic {
    type    = "TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST"
    percent = 100
  }
  
  depends_on = [google_project_service.run_api]
}

# Service account for the Cloud Run service
resource "google_service_account" "app_sa" {
  account_id   = "{{ service_name }}-sa"
  display_name = "Service account for {{ service_name }}"
}

# IAM binding to allow unauthenticated access (if enabled)
resource "google_cloud_run_v2_service_iam_member" "public_access" {
  count    = var.allow_unauthenticated ? 1 : 0
  
  project  = google_cloud_run_v2_service.app.project
  location = google_cloud_run_v2_service.app.location
  name     = google_cloud_run_v2_service.app.name
  role     = "roles/run.invoker"
  member   = "allUsers"
}
'''

VARIABLES_TF_TEMPLATE = '''# Variables for {{ service_name }}

variable "project_id" {
  description = "Google Cloud project ID"
  type        = string
}

variable "region" {
  description = "Google Cloud region"
  type        = string
  default     = "{{ default_region }}"
}

variable "service_name" {
  description = "Name of the Cloud Run service"
  type        = string
  default     = "{{ service_name }}"
}

variable "container_image" {
  description = "Container image to deploy"
  type        = string
}

variable "container_port" {
  description = "Port the container listens on"
  type        = number
  default     = {{ port }}
}

variable "health_check_path" {
  description = "Path for health check endpoint"
  type        = string
  default     = "{{ health_check_path }}"
}

variable "cpu" {
  description = "CPU limit"
  type        = string
  default     = "1"
}

variable "memory" {
  description = "Memory limit"
  type        = string
  default     = "512Mi"
}

variable "min_instances" {
  description = "Minimum number of instances"
  type        = number
  default     = 0
}

variable "max_instances" {
  description = "Maximum number of instances"
  type        = number
  default     = 10
}

variable "allow_unauthenticated" {
  description = "Allow unauthenticated access"
  type        = bool
  default     = {{ allow_unauthenticated | lower }}
}
'''

OUTPUTS_TF_TEMPLATE = '''# Outputs for {{ service_name }}

output "service_url" {
  description = "URL of the deployed Cloud Run service"
  value       = google_cloud_run_v2_service.app.uri
}

output "service_name" {
  description = "Name of the Cloud Run service"
  value       = google_cloud_run_v2_service.app.name
}

output "service_account" {
  description = "Service account email"
  value       = google_service_account.app_sa.email
}

output "artifact_registry_url" {
  description = "Artifact Registry repository URL"
  value       = "${var.region}-docker.pkg.dev/${var.project_id}/${google_artifact_registry_repository.app_repo.repository_id}"
}
'''

TFVARS_EXAMPLE_TEMPLATE = '''# Example terraform.tfvars for {{ service_name }}
# Copy this file to terraform.tfvars and fill in your values

project_id = "your-gcp-project-id"
region     = "{{ default_region }}"

# Container image (after initial build)
container_image = "{{ default_region }}-docker.pkg.dev/your-project/{{ service_name }}/{{ service_name }}:latest"

# Optional overrides
# container_port        = {{ port }}
# health_check_path     = "{{ health_check_path }}"
# min_instances         = 0
# max_instances         = 10
# allow_unauthenticated = true
'''


class InfraAgent(BaseAgent):
    """
    Generates infrastructure as code:
    - Terraform configurations
    - Cloud Run service definitions
    - IAM and networking
    - Auto-apply deployment (optional)
    """
    
    def __init__(self, working_dir: Path = None, gemini_client=None):
        super().__init__("InfraAgent", working_dir, gemini_client)
        self.terraform = None  # Initialized when needed
        self.health_checker = HealthChecker()
    
    def _get_system_instruction(self) -> str:
        return """You are an infrastructure expert specializing in Terraform and Google Cloud.
You create secure, scalable infrastructure configurations following best practices.
Use proper resource naming, enable appropriate APIs, and configure IAM correctly."""
    
    async def run(
        self, 
        project_info: ProjectInfo,
        config: DeploymentConfig = None,
        auto_apply: bool = False,  # NEW: Auto-apply Terraform
        verify_deployment: bool = True,  # NEW: Verify after deployment
        terraform_vars: Dict[str, str] = None,  # NEW: Terraform variables
    ) -> Dict[str, Any]:
        """
        Generate Terraform infrastructure configuration.
        
        Args:
            project_info: Analyzed project information
            config: Deployment configuration
            auto_apply: Whether to automatically apply Terraform
            verify_deployment: Whether to verify deployment health
            terraform_vars: Terraform variable overrides
            
        Returns:
            Dict with generated Terraform files and deployment results
        """
        config = config or self._create_default_config(project_info)
        
        result = {
            "success": True,
            "files": {},
            "terraform_commands": [],
            "deployment": None,
            "service_url": None,
        }
        
        try:
            # Create terraform directory
            tf_dir = project_info.path / "terraform"
            await self.file_manager.create_directory(tf_dir)
            
            # Step 1: Generate main.tf
            self.log_step("Generating main.tf", 1)
            main_tf = await self._generate_main_tf(project_info, config)
            main_path = tf_dir / "main.tf"
            await self.file_manager.write_file(main_path, main_tf)
            result["files"]["main.tf"] = main_tf
            
            # Step 2: Generate variables.tf
            self.log_step("Generating variables.tf", 2)
            variables_tf = self._generate_variables_tf(project_info, config)
            variables_path = tf_dir / "variables.tf"
            await self.file_manager.write_file(variables_path, variables_tf)
            result["files"]["variables.tf"] = variables_tf
            
            # Step 3: Generate outputs.tf
            self.log_step("Generating outputs.tf", 3)
            outputs_tf = self._generate_outputs_tf(project_info, config)
            outputs_path = tf_dir / "outputs.tf"
            await self.file_manager.write_file(outputs_path, outputs_tf)
            result["files"]["outputs.tf"] = outputs_tf
            
            # Step 4: Generate terraform.tfvars.example
            self.log_step("Generating terraform.tfvars.example", 4)
            tfvars = self._generate_tfvars_example(project_info, config)
            tfvars_path = tf_dir / "terraform.tfvars.example"
            await self.file_manager.write_file(tfvars_path, tfvars)
            result["files"]["terraform.tfvars.example"] = tfvars
            
            # Step 5: Generate .gitignore for terraform
            self.log_step("Generating Terraform .gitignore", 5)
            gitignore = self._generate_tf_gitignore()
            gitignore_path = tf_dir / ".gitignore"
            await self.file_manager.write_file(gitignore_path, gitignore)
            result["files"][".gitignore"] = gitignore
            
            # Step 6: Auto-apply if requested
            if auto_apply:
                self.log_step("Applying Terraform configuration", 6)
                deployment_result = await self._apply_terraform(
                    tf_dir, terraform_vars
                )
                result["deployment"] = deployment_result
                
                if deployment_result.get("success"):
                    result["service_url"] = deployment_result.get("outputs", {}).get("service_url")
                    
                    # Step 7: Verify deployment
                    if verify_deployment and result["service_url"]:
                        self.log_step("Verifying deployment", 7)
                        health_result = await verify_deployment(
                            url=result["service_url"],
                            health_path="/health",
                            timeout=180,
                        )
                        result["deployment"]["health_check"] = health_result
                else:
                    result["success"] = False
            else:
                # Add terraform commands for manual execution
                result["terraform_commands"] = self._get_terraform_commands()
            
            self.log_success("Infrastructure configuration generated successfully")
            
        except Exception as e:
            result["success"] = False
            result["error"] = str(e)
            self.log_error(f"Infrastructure generation failed: {e}", e)
        
        return result
    
    async def _apply_terraform(
        self,
        terraform_dir: Path,
        variables: Dict[str, str] = None,
    ) -> Dict[str, Any]:
        """
        Apply Terraform configuration.
        
        Args:
            terraform_dir: Directory containing Terraform files
            variables: Variable overrides
            
        Returns:
            Deployment result dict
        """
        from ..core.terraform_client import TerraformClient, deploy_infrastructure
        
        try:
            apply_result = await deploy_infrastructure(
                terraform_dir=terraform_dir,
                variables=variables,
                auto_approve=True,
            )
            
            return {
                "success": apply_result.success,
                "outputs": apply_result.outputs,
                "resources_created": apply_result.resources_created,
                "errors": apply_result.errors,
                "duration": apply_result.duration_seconds,
            }
        except Exception as e:
            self.logger.error(f"Terraform apply failed: {e}")
            return {
                "success": False,
                "errors": [str(e)],
            }
    
    def _create_default_config(self, project_info: ProjectInfo) -> DeploymentConfig:
        """Create default deployment configuration."""
        service_name = project_info.name.lower().replace(" ", "-").replace("_", "-")
        
        container_config = ContainerConfig(
            image_name=service_name,
            port=project_info.port,
        )
        
        return DeploymentConfig(
            provider=CloudProvider.GCP,
            service_name=service_name,
            container=container_config,
            allow_unauthenticated=True,
            health_check_path=project_info.health_endpoint or "/health",
        )
    
    async def _generate_main_tf(
        self, 
        project_info: ProjectInfo, 
        config: DeploymentConfig
    ) -> str:
        """Generate main.tf file."""
        context = self._build_context(project_info, config)
        return self.file_manager.render_template(MAIN_TF_TEMPLATE, context)
    
    def _generate_variables_tf(
        self, 
        project_info: ProjectInfo, 
        config: DeploymentConfig
    ) -> str:
        """Generate variables.tf file."""
        context = self._build_context(project_info, config)
        return self.file_manager.render_template(VARIABLES_TF_TEMPLATE, context)
    
    def _generate_outputs_tf(
        self, 
        project_info: ProjectInfo, 
        config: DeploymentConfig
    ) -> str:
        """Generate outputs.tf file."""
        context = self._build_context(project_info, config)
        return self.file_manager.render_template(OUTPUTS_TF_TEMPLATE, context)
    
    def _generate_tfvars_example(
        self, 
        project_info: ProjectInfo, 
        config: DeploymentConfig
    ) -> str:
        """Generate terraform.tfvars.example file."""
        context = self._build_context(project_info, config)
        return self.file_manager.render_template(TFVARS_EXAMPLE_TEMPLATE, context)
    
    def _build_context(
        self, 
        project_info: ProjectInfo, 
        config: DeploymentConfig
    ) -> Dict[str, Any]:
        """Build template context."""
        service_name = config.service_name or project_info.name.lower().replace(" ", "-")
        
        return {
            "service_name": service_name,
            "port": project_info.port,
            "health_check_path": config.health_check_path or "/health",
            "default_region": config.region,
            "allow_unauthenticated": config.allow_unauthenticated,
            "env_vars": {},  # Can be populated from project_info.required_env_vars
        }
    
    def _generate_tf_gitignore(self) -> str:
        """Generate .gitignore for Terraform."""
        return '''# Terraform
*.tfstate
*.tfstate.*
*.tfvars
!*.tfvars.example
.terraform/
.terraform.lock.hcl
crash.log
override.tf
override.tf.json
*_override.tf
*_override.tf.json
'''
    
    def _get_terraform_commands(self) -> List[str]:
        """Get Terraform commands to run."""
        return [
            "cd terraform",
            "cp terraform.tfvars.example terraform.tfvars",
            "# Edit terraform.tfvars with your values",
            "terraform init",
            "terraform plan",
            "terraform apply",
        ]
    
    async def check_prerequisites(self) -> Dict[str, bool]:
        """Check if Terraform is available."""
        tf_available = await self.executor.check_tool_exists("terraform")
        tf_version = await self.executor.get_tool_version("terraform")
        
        return {
            "terraform": tf_available,
            "terraform_version": tf_version,
        }
